### Расширение через абстрагирование

Попробуем теперь по шагам воспроизвести последовательность шагов, которые мы сделали бы в реальном мире для предоставления функциональности подключения новых видов кофе-машин к нашей платформе. Предположим, что изначально наше API вообще не предоставляло никакого доступа к управлению запуском программ — единственными эндпойнтами, доступным клиенту, были бы функции поиска предложений и создания заказа.

```
let searchResults = api.search({
    /* выбранные пользователем параметры */
});

/* пользователь как-то взаимодействует
   с результатами поиска и выбирает
   конкретное предложение */

let selectedResult = userPick(searchResults);

api.postOrder({
    offer: selectedResult.offer
});
```

На данном этапе вообще нет таких понятий, как «идентификатор кофе-машины» или «идентификатор рецепта» — достаточно передать только лишь оффер. Нужные идентификаторы могут храниться в базе данных по идентификатору оффера или быть закодированными в самом идентификаторе.

**NB**: тем не менее, обратите внимание не то, что, хотя никакие данные помимо оффера для заказа не нужны, мы, тем не менее, оставили возможность эти данные передавать: функция placeOrder принимает не offerId, а потенциально расширяемую структуру данных.

API для регистрации своего обработчика запуска программ мы предложили в предыдущей главе:

```
api.registerProgramRunHandler(
    apiType,
    function (program) {

    }
);
```

Заметим, что партнёр мог бы не пользоваться ни одной из вышеперечисленных функций (`search`, `postOrder`, `registerProgramHandler`) и попросту написать реализацию выбора и заказа напитка сам. Тогда, правда, возникает вопрос, зачем ему вообще тогда нужно наше API (см. «какую проблему мы решаем», [Глава 8](#chapter-8)). Предположим всё-таки, что партнёр не строит полностью свой сервис, а только встраивает свои собственные кофейни в нашу платформу. Как и раньше, мы рассматриваем динамическое связывание на клиенте в реальном времени в учебных целях, в реальной жизни такая функциональность предоставлялась бы как серверное партнёрское API.

Для полностью рабочей интеграции на данном этапе осталось два шага:
  * указать соответствие рецептов и программ для нового типа API;
  * предоставить список партнерских кофе-машин.

```
api.setRecipePrograms(apiType, [{
    "recipe_id",
    "programRunParameters": {
        /* какое-то описание
           параметров запуска
           программы */
    }
}]);

/* Во избежание коллизий сразу
   заводим составные идентификаторы,
   поэтому функция должна 
   их в каком-то виде возвращать */
let coffeeMachinesList = 
    api.coffeeMachines.putList({
        namespace: partnerId,
        coffeeMachines: [{
            internalId,
            apiType
        }, …]
    });
```

Теперь вся конструкция должна работать. Займёмся теперь, однако, вот каким упражнением:
  1. Перечислим все неявные предположения, которые мы допустили.
  2. Перечислим все неявные механизмы связывания, которые необходимы для функционирования платформы.

Может показаться, что в нашем API нет ни того, ни другого — но это неправда. Список таких неявностей довольно велик.
  1. Cтатической информации, которую мы передаём внутри `supportedRecipes.program`, достаточно для запуска программы на исполнение, и она не зависит от конкретной кофе-машины.
  2. Каждая кофе-машина поддерживает все возможные параметры рецепта (например, допустимый объём напитка).
  3. Кофе-машины партнёра не требуется как-то специально выделять в списке результатов поиска, они имеют точно такую же карточку результата, как и предложения других партнеров, и ранжируются на общих основаниях.
  4. Обработчик `postOrder` производит все необходимые проверки (например, действительно ли на данной кофе-машине можно сварить кофе по указанному рецепту), в том числе определяет тип API по офферу, и инициирует запуск нужной программы.
  5. Цена напитка не зависит ни от партнёра, ни от типа кофе-машины.

Все эти пункты мы выписали с одной целью: нам нужно понять, каким конкретно образом мы будем переводить неявные договорённости в явные, если нам это потребуется. Например, если разные кофе-машины предоставляют разный объём функциональности — допустим, в каких-то кофейнях не посыпают корицей — что должно измениться в нашем API? 

Самое простое решение, шаг 1: при регистрации кофе машины указать, какие опции она поддерживает.

Следующий вопрос: а *что, если* корицей вообще-то посыпают, но прямо сейчас она закончилась? Исходя из изложенного в предыдущей главе, нам тогда каким-то образом необходимо организовать поток обновлений состояния кофе-машин — это шаг 2.

А *что, если* корица закончилась в промежутке времени между получением заказа и его исполнением? Нужна тогда обратная связь, сообщение от уровня исполнения о невозможности исполнить заказ — это шаг 3.

На первый взгляд, на каждом шаге мы гадаем на кофейной гуще. Если нужно будет реализовать вот это, то мы поступим вот так. Но, если присмотреться внимательно, то закономерность можно найти: мы каждый раз берём какой-то частный случай и заменяем его более общим.

На шаге 2 нам нужно имплементировать две операции: (а) получение текущего списка поддерживаемых опций, (б) его динамическое обновление по наступлению какого-то события. Но ведь операции (а) нам как раз было бы достаточно, чтобы реализовать функциональность шага 1, т.е. предоставить информацию о поддерживаемых опциях статически.

На шаге 3 нам нужно на уровне запуска программ имплементировать поддержку определения количества доступной корицы и ввести какой-то сигнал о его изменении. Как только мы это сделаем — мы немедленно сможем реализовать операции (а) и (б), необходимые нам на шаге 2.

Если бы мы начинали сразу с шага 3, то никакой проблемы предоставить функциональность в объёме шагов 1 и 2 у нас бы не возникло. Но вот обратное неверно: мы можем так реализовать предыдущий шаг, что последующий шаг потребует введения излишних концепций или просто окажется невозможен без слома обратной совместимости. Например, если на шаге 1 мы привяжем определение доступности опции к офферу:

```
// возвращает список доступных опций
selectedResult.offer.getAvailableOptions()
```

Такое связывание прекрасно работает, пока мы оперируем неизменяемым фактом наличия или отсутствия поддержки опции. Но на шаге 3 такой интерфейс начинает вызывать большие вопросы: должен ли этот метод продолжать работать, если по офферу был сделан заказ? Если да, то, выходит, оффер должен уметь обратиться к рантайму кофе-машины, для которой был создан — что абсолютно точно вне его области ответственности. Если нет — тогда у нас получится два разных метода `getAvailableOptions` у двух разных объектов (один из них оффер, а второй, по-видимому, придётся привязать к сущности «заказ»), один имеет смысл до заказа, а другой — после (и тут ещё надо каким-то образом определить, что считается моментом заказа); и нам придётся ещё как-то объяснять, когда пользоваться первым, а когда вторым, и почему они могут вернуть разный результат.

Для того, чтобы избежать подобного рода проблем, нужно научиться «думать с конца»: предоставляя любой интерфейс нужно думать о нём как о частной реализации какой-то более общей логики, как о некотором шорткате или хэлпере для облегчения жизни разработчика, чтобы ему не приходилось зарываться в более слои документации. В частности, нужно чётко понимать, откуда финально берётся та информация, которую мы предоставляем через «шорткат»: указанной ошибки в связывании опций с оффером можно легко избежать, если вспомнить о том, что информация о наличии корицы приходит откуда-то из реального мира, или от датчика, или от баристы, никак не из нашей виртуальной системы офферов.

Вернёмся теперь к списку неявностей, который мы сформулировали в начале главы, и попробуем применить сформулированный выше принцип к каждому из пунктов.

1. Cтатической информации, которую мы передаём внутри `supportedRecipes.program`, достаточно для запуска программы на исполнение, и она не зависит от конкретной кофе-машины.

Статическая передача параметров в program — это частный случай динамической. Мы можем дать возможность сформировать параметры запуска программы динамически, а передачу `program` в `setRecipePrograms` объявить просто шорткатом для тех ситуаций, когда дополнительно формировать параметры не требуется. Например, так:

```
api.setRecipePrograms(apiType, [{
    "recipe_id",
    /* Можно задать одно из двух,
       либо поле `program`
    "programRunParameters": { … }
       либо функцию формирования
       параметров запуска */
    "programRunParametersGenerator":
        function (order) {
            return {
                // Это статический параметр
                "program_id": 123,
                // А это динамический
                "volume": order.volume
            };
        }
}]);
```

**NB**: альтернативно можно развивать декларативный формат описания параметров, разрешив в нём подстановки и вычисления. Это упражнение мы оставим читателю.

2. Каждая кофе-машина поддерживает все возможные параметры рецепта (например, допустимый объём напитка).

Поддержка всех возможных параметров - это частный случай. Мы предоставили шорткат для того, чтобы 

3. Кофе-машины партнёра не требуется как-то специально выделять в списке результатов поиска, они имеют точно такую же карточку результата, как и предложения других партнеров, и ранжируются на общих основаниях;
4. Обработчик `postOrder` производит все необходимые проверки (например, действительно ли на данной кофе-машине можно сварить кофе по указанному рецепту), в том числе определяет тип API по офферу, и инициирует запуск нужной программы;
5. Цена напитка не зависит ни от партнёра, ни от типа кофе-машины.
